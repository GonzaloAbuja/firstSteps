{
  "version": 3,
  "sources": ["../../ol/source/common.js", "../../ol/source/wms.js", "../../ol/source/TileWMS.js"],
  "sourcesContent": ["/**\r\n * @module ol/source/common\r\n */\r\n\r\n/**\r\n * Default WMS version.\r\n * @type {string}\r\n */\r\nexport const DEFAULT_WMS_VERSION = '1.3.0';\r\n\r\n/**\r\n * Number of decimal digits to consider in integer values when rounding.\r\n * @type {number}\r\n */\r\nexport const DECIMALS = 4;\r\n", "/**\r\n * @module ol/source/wms\r\n */\r\n\r\nimport {DECIMALS} from './common.js';\r\nimport {appendParams} from '../uri.js';\r\nimport {compareVersions} from '../string.js';\r\nimport {decode} from '../Image.js';\r\nimport {floor, round} from '../math.js';\r\nimport {getForViewAndSize, getHeight, getWidth} from '../extent.js';\r\nimport {get as getProjection} from '../proj.js';\r\nimport {getRequestExtent} from './Image.js';\r\n\r\n/**\r\n * Default WMS version.\r\n * @type {string}\r\n */\r\nexport const DEFAULT_VERSION = '1.3.0';\r\n\r\n/**\r\n * @const\r\n * @type {import(\"../size.js\").Size}\r\n */\r\nconst GETFEATUREINFO_IMAGE_SIZE = [101, 101];\r\n\r\n/**\r\n * @api\r\n * @typedef {'carmentaserver' | 'geoserver' | 'mapserver' | 'qgis'} ServerType\r\n * Set the server type to use implementation-specific parameters beyond the WMS specification.\r\n *  - `'carmentaserver'`: HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)\r\n *  - `'geoserver'`: HiDPI support for [GeoServer](https://geoserver.org/)\r\n *  - `'mapserver'`: HiDPI support for [MapServer](https://mapserver.org/)\r\n *  - `'qgis'`: HiDPI support for [QGIS](https://qgis.org/)\r\n */\r\n\r\n/**\r\n * @param {string} baseUrl Base URL.\r\n * @param {import(\"../extent.js\").Extent} extent Extent.\r\n * @param {import(\"../size.js\").Size} size Size.\r\n * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n * @param {Object} params WMS params. Will be modified in place.\r\n * @return {string} Request URL.\r\n */\r\nexport function getRequestUrl(baseUrl, extent, size, projection, params) {\r\n  params['WIDTH'] = size[0];\r\n  params['HEIGHT'] = size[1];\r\n\r\n  const axisOrientation = projection.getAxisOrientation();\r\n  let bbox;\r\n  const v13 = compareVersions(params['VERSION'], '1.3') >= 0;\r\n  params[v13 ? 'CRS' : 'SRS'] = projection.getCode();\r\n  if (v13 && axisOrientation.substr(0, 2) == 'ne') {\r\n    bbox = [extent[1], extent[0], extent[3], extent[2]];\r\n  } else {\r\n    bbox = extent;\r\n  }\r\n  params['BBOX'] = bbox.join(',');\r\n\r\n  return appendParams(/** @type {string} */ (baseUrl), params);\r\n}\r\n\r\n/**\r\n * @param {import(\"../extent\").Extent} extent Extent.\r\n * @param {number} resolution Resolution.\r\n * @param {number} pixelRatio pixel ratio.\r\n * @param {import(\"../proj.js\").Projection} projection Projection.\r\n * @param {string} url WMS service url.\r\n * @param {Object} params WMS params.\r\n * @param {import(\"./wms.js\").ServerType} serverType The type of the remote WMS server.\r\n * @return {string} Image src.\r\n */\r\nexport function getImageSrc(\r\n  extent,\r\n  resolution,\r\n  pixelRatio,\r\n  projection,\r\n  url,\r\n  params,\r\n  serverType,\r\n) {\r\n  params = Object.assign({REQUEST: 'GetMap'}, params);\r\n\r\n  const imageResolution = resolution / pixelRatio;\r\n\r\n  const imageSize = [\r\n    round(getWidth(extent) / imageResolution, DECIMALS),\r\n    round(getHeight(extent) / imageResolution, DECIMALS),\r\n  ];\r\n\r\n  if (pixelRatio != 1) {\r\n    switch (serverType) {\r\n      case 'geoserver':\r\n        const dpi = (90 * pixelRatio + 0.5) | 0;\r\n        if ('FORMAT_OPTIONS' in params) {\r\n          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;\r\n        } else {\r\n          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;\r\n        }\r\n        break;\r\n      case 'mapserver':\r\n        params['MAP_RESOLUTION'] = 90 * pixelRatio;\r\n        break;\r\n      case 'carmentaserver':\r\n      case 'qgis':\r\n        params['DPI'] = 90 * pixelRatio;\r\n        break;\r\n      default:\r\n        throw new Error('Unknown `serverType` configured');\r\n    }\r\n  }\r\n\r\n  const src = getRequestUrl(url, extent, imageSize, projection, params);\r\n  return src;\r\n}\r\n\r\n/**\r\n * @param {Object} params WMS params.\r\n * @param {string} request WMS `REQUEST`.\r\n * @return {Object} WMS params with required properties set.\r\n */\r\nexport function getRequestParams(params, request) {\r\n  return Object.assign(\r\n    {\r\n      'REQUEST': request,\r\n      'SERVICE': 'WMS',\r\n      'VERSION': DEFAULT_VERSION,\r\n      'FORMAT': 'image/png',\r\n      'STYLES': '',\r\n      'TRANSPARENT': true,\r\n    },\r\n    params,\r\n  );\r\n}\r\n\r\n/**\r\n * @typedef {Object} LoaderOptions\r\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\r\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\r\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\r\n * the image from the remote server.\r\n * @property {Object<string,*>} [params] WMS request parameters.\r\n * At least a `LAYERS` param is required. `STYLES` is\r\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT` and `BBOX` will be set\r\n * dynamically. `CRS` (`SRS` for WMS version < 1.3.0) will is derived from the `proection` config.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is 'EPSG:3857'.\r\n * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means\r\n * twice the width and height of the map viewport, and so on. Must be `1` or higher.\r\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\r\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\r\n * Only needed if `hidpi` is `true`.\r\n * @property {string} url WMS service URL.\r\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\r\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\r\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\r\n */\r\n\r\n/**\r\n * Creates a loader for WMS images.\r\n * @param {LoaderOptions} options Loader options.\r\n * @return {import(\"../Image.js\").ImageObjectPromiseLoader} Loader.\r\n * @api\r\n */\r\nexport function createLoader(options) {\r\n  const hidpi = options.hidpi === undefined ? true : options.hidpi;\r\n  const projection = getProjection(options.projection || 'EPSG:3857');\r\n  const ratio = options.ratio || 1.5;\r\n  const load = options.load || decode;\r\n\r\n  /**\r\n   * @type {import(\"../Image.js\").Loader}\r\n   */\r\n  return (extent, resolution, pixelRatio) => {\r\n    extent = getRequestExtent(extent, resolution, pixelRatio, ratio);\r\n    if (pixelRatio != 1 && (!hidpi || options.serverType === undefined)) {\r\n      pixelRatio = 1;\r\n    }\r\n    const src = getImageSrc(\r\n      extent,\r\n      resolution,\r\n      pixelRatio,\r\n      projection,\r\n      options.url,\r\n      getRequestParams(options.params, 'GetMap'),\r\n      options.serverType,\r\n    );\r\n    const image = new Image();\r\n    if (options.crossOrigin !== null) {\r\n      image.crossOrigin = options.crossOrigin;\r\n    }\r\n    return load(image, src).then((image) => ({image, extent, pixelRatio}));\r\n  };\r\n}\r\n\r\n/**\r\n * Get the GetFeatureInfo URL for the passed coordinate and resolution. Returns `undefined` if the\r\n * GetFeatureInfo URL cannot be constructed.\r\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function. In addition to\r\n * the params required by the loader, `INFO_FORMAT` should be specified, it defaults to\r\n * `application/json`. If `QUERY_LAYERS` is not provided, then the layers specified in the `LAYERS`\r\n * parameter will be used.\r\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n * @param {number} resolution Resolution.\r\n * @return {string|undefined} GetFeatureInfo URL.\r\n * @api\r\n */\r\nexport function getFeatureInfoUrl(options, coordinate, resolution) {\r\n  if (options.url === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  const projectionObj = getProjection(options.projection || 'EPSG:3857');\r\n\r\n  const extent = getForViewAndSize(\r\n    coordinate,\r\n    resolution,\r\n    0,\r\n    GETFEATUREINFO_IMAGE_SIZE,\r\n  );\r\n\r\n  const baseParams = {\r\n    'QUERY_LAYERS': options.params['LAYERS'],\r\n    'INFO_FORMAT': 'application/json',\r\n  };\r\n  Object.assign(\r\n    baseParams,\r\n    getRequestParams(options.params, 'GetFeatureInfo'),\r\n    options.params,\r\n  );\r\n\r\n  const x = floor((coordinate[0] - extent[0]) / resolution, DECIMALS);\r\n  const y = floor((extent[3] - coordinate[1]) / resolution, DECIMALS);\r\n  const v13 = compareVersions(baseParams['VERSION'], '1.3') >= 0;\r\n  baseParams[v13 ? 'I' : 'X'] = x;\r\n  baseParams[v13 ? 'J' : 'Y'] = y;\r\n\r\n  return getRequestUrl(\r\n    options.url,\r\n    extent,\r\n    GETFEATUREINFO_IMAGE_SIZE,\r\n    projectionObj,\r\n    baseParams,\r\n  );\r\n}\r\n\r\n/**\r\n * Get the GetLegendGraphic URL, optionally optimized for the passed resolution and possibly\r\n * including any passed specific parameters. Returns `undefined` if the GetLegendGraphic URL\r\n * cannot be constructed.\r\n *\r\n * @param {LoaderOptions} options Options passed the `createWMSLoader()` function.\r\n * @param {number} [resolution] Resolution. If not provided, `SCALE` will not be calculated and\r\n * included in URL.\r\n * @return {string|undefined} GetLegendGraphic URL.\r\n * @api\r\n */\r\nexport function getLegendUrl(options, resolution) {\r\n  if (options.url === undefined) {\r\n    return undefined;\r\n  }\r\n\r\n  const baseParams = {\r\n    'SERVICE': 'WMS',\r\n    'VERSION': DEFAULT_VERSION,\r\n    'REQUEST': 'GetLegendGraphic',\r\n    'FORMAT': 'image/png',\r\n  };\r\n\r\n  if (options.params === undefined || options.params['LAYER'] === undefined) {\r\n    const layers = options.params.LAYERS;\r\n    const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\r\n    if (!isSingleLayer) {\r\n      return undefined;\r\n    }\r\n    baseParams['LAYER'] = layers;\r\n  }\r\n\r\n  if (resolution !== undefined) {\r\n    const mpu =\r\n      getProjection(options.projection || 'EPSG:3857').getMetersPerUnit() || 1;\r\n    const pixelSize = 0.00028;\r\n    baseParams['SCALE'] = (resolution * mpu) / pixelSize;\r\n  }\r\n\r\n  Object.assign(baseParams, options.params);\r\n\r\n  return appendParams(options.url, baseParams);\r\n}\r\n", "/**\r\n * @module ol/source/TileWMS\r\n */\r\n\r\nimport TileImage from './TileImage.js';\r\nimport {DEFAULT_VERSION, getImageSrc, getRequestParams} from './wms.js';\r\nimport {appendParams} from '../uri.js';\r\nimport {buffer, createEmpty} from '../extent.js';\r\nimport {calculateSourceResolution} from '../reproj.js';\r\nimport {compareVersions} from '../string.js';\r\nimport {get as getProjection, transform} from '../proj.js';\r\nimport {modulo} from '../math.js';\r\nimport {hash as tileCoordHash} from '../tilecoord.js';\r\n\r\n/**\r\n * @typedef {Object} Options\r\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\r\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\r\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\r\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\r\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\r\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\r\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\r\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\r\n * @property {Object<string,*>} params WMS request parameters.\r\n * At least a `LAYERS` param is required. `STYLES` is\r\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\r\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\r\n * @property {number} [gutter=0]\r\n * The size in pixels of the gutter around image tiles to ignore. By setting\r\n * this property to a non-zero value, images will be requested that are wider\r\n * and taller than the tile size by a value of `2 x gutter`.\r\n * Using a non-zero value allows artifacts of rendering at tile edges to be\r\n * ignored. If you control the WMS service it is recommended to address\r\n * \"artifacts at tile edges\" issues by properly configuring the WMS service. For\r\n * example, MapServer has a `tile_map_edge_buffer` configuration parameter for\r\n * this. See https://mapserver.org/output/tile_mode.html.\r\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\r\n * the image from the remote server.\r\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\r\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\r\n * Higher values can increase reprojection performance, but decrease precision.\r\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\r\n * Default is {@link module:ol/ImageTile~ImageTile}.\r\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\r\n * tilesize and extent supported by the server.\r\n * If this is not defined, a default grid will be used: if there is a projection\r\n * extent, the grid will be based on that; if not, a grid based on a global\r\n * extent with origin at 0,0 will be used.\r\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\r\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\r\n * Only needed if `hidpi` is `true`.\r\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\r\n * ```js\r\n * function(imageTile, src) {\r\n *   imageTile.getImage().src = src;\r\n * };\r\n * ```\r\n * @property {string} [url] WMS service URL.\r\n * @property {Array<string>} [urls] WMS service urls.\r\n * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.\r\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\r\n * When set to `false`, only one world\r\n * will be rendered. When `true`, tiles will be requested for one world only,\r\n * but they will be wrapped horizontally to render multiple worlds.\r\n * @property {number} [transition] Duration of the opacity transition for rendering.\r\n * To disable the opacity transition, pass `transition: 0`.\r\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\r\n * Choose whether to use tiles with a higher or lower zoom level when between integer\r\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * Layer source for tile data from WMS servers.\r\n * @api\r\n */\r\nclass TileWMS extends TileImage {\r\n  /**\r\n   * @param {Options} [options] Tile WMS options.\r\n   */\r\n  constructor(options) {\r\n    options = options ? options : /** @type {Options} */ ({});\r\n\r\n    const params = Object.assign({}, options.params);\r\n\r\n    const transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;\r\n\r\n    super({\r\n      attributions: options.attributions,\r\n      attributionsCollapsible: options.attributionsCollapsible,\r\n      cacheSize: options.cacheSize,\r\n      crossOrigin: options.crossOrigin,\r\n      interpolate: options.interpolate,\r\n      opaque: !transparent,\r\n      projection: options.projection,\r\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\r\n      tileClass: options.tileClass,\r\n      tileGrid: options.tileGrid,\r\n      tileLoadFunction: options.tileLoadFunction,\r\n      url: options.url,\r\n      urls: options.urls,\r\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\r\n      transition: options.transition,\r\n      zDirection: options.zDirection,\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     */\r\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\r\n\r\n    /**\r\n     * @private\r\n     * @type {!Object}\r\n     */\r\n    this.params_ = params;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.v13_ = true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"./wms.js\").ServerType}\r\n     */\r\n    this.serverType_ = options.serverType;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\r\n\r\n    /**\r\n     * @private\r\n     * @type {import(\"../extent.js\").Extent}\r\n     */\r\n    this.tmpExtent_ = createEmpty();\r\n\r\n    this.updateV13_();\r\n    this.setKey(this.getKeyForParams_());\r\n  }\r\n\r\n  /**\r\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\r\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\r\n   * constructed.\r\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\r\n   * @param {number} resolution Resolution.\r\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\r\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\r\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\r\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\r\n   *     specified here.\r\n   * @return {string|undefined} GetFeatureInfo URL.\r\n   * @api\r\n   */\r\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\r\n    const projectionObj = getProjection(projection);\r\n    const sourceProjectionObj = this.getProjection() || projectionObj;\r\n\r\n    let tileGrid = this.getTileGrid();\r\n    if (!tileGrid) {\r\n      tileGrid = this.getTileGridForProjection(sourceProjectionObj);\r\n    }\r\n\r\n    const sourceProjCoord = transform(\r\n      coordinate,\r\n      projectionObj,\r\n      sourceProjectionObj,\r\n    );\r\n    const sourceResolution = calculateSourceResolution(\r\n      sourceProjectionObj,\r\n      projectionObj,\r\n      coordinate,\r\n      resolution,\r\n    );\r\n\r\n    const z = tileGrid.getZForResolution(sourceResolution, this.zDirection);\r\n    const tileResolution = tileGrid.getResolution(z);\r\n    const tileCoord = tileGrid.getTileCoordForCoordAndZ(sourceProjCoord, z);\r\n\r\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\r\n      return undefined;\r\n    }\r\n\r\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n\r\n    const gutter = this.gutter_;\r\n    if (gutter !== 0) {\r\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\r\n    }\r\n\r\n    const baseParams = {\r\n      'QUERY_LAYERS': this.params_['LAYERS'],\r\n    };\r\n    Object.assign(\r\n      baseParams,\r\n      getRequestParams(this.params_, 'GetFeatureInfo'),\r\n      params,\r\n    );\r\n\r\n    const x = Math.floor((sourceProjCoord[0] - tileExtent[0]) / tileResolution);\r\n    const y = Math.floor((tileExtent[3] - sourceProjCoord[1]) / tileResolution);\r\n\r\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\r\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\r\n\r\n    return this.getRequestUrl_(\r\n      tileCoord,\r\n      tileExtent,\r\n      1,\r\n      sourceProjectionObj || projectionObj,\r\n      baseParams,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\r\n   * resolution and possibly including any passed specific parameters. Returns\r\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\r\n   *\r\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\r\n   *     will not be calculated and included in URL.\r\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\r\n   *     request is generated for this wms layer, else it will try to use the\r\n   *     configured wms layer. Default `FORMAT` is `image/png`.\r\n   *     `VERSION` should not be specified here.\r\n   * @return {string|undefined} GetLegendGraphic URL.\r\n   * @api\r\n   */\r\n  getLegendUrl(resolution, params) {\r\n    if (this.urls[0] === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    const baseParams = {\r\n      'SERVICE': 'WMS',\r\n      'VERSION': DEFAULT_VERSION,\r\n      'REQUEST': 'GetLegendGraphic',\r\n      'FORMAT': 'image/png',\r\n    };\r\n\r\n    if (params === undefined || params['LAYER'] === undefined) {\r\n      const layers = this.params_.LAYERS;\r\n      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\r\n      if (!isSingleLayer) {\r\n        return undefined;\r\n      }\r\n      baseParams['LAYER'] = layers;\r\n    }\r\n\r\n    if (resolution !== undefined) {\r\n      const mpu = this.getProjection()\r\n        ? this.getProjection().getMetersPerUnit()\r\n        : 1;\r\n      const pixelSize = 0.00028;\r\n      baseParams['SCALE'] = (resolution * mpu) / pixelSize;\r\n    }\r\n\r\n    Object.assign(baseParams, params);\r\n\r\n    return appendParams(/** @type {string} */ (this.urls[0]), baseParams);\r\n  }\r\n\r\n  /**\r\n   * @return {number} Gutter.\r\n   */\r\n  getGutter() {\r\n    return this.gutter_;\r\n  }\r\n\r\n  /**\r\n   * Get the user-provided params, i.e. those passed to the constructor through\r\n   * the \"params\" option, and possibly updated using the updateParams method.\r\n   * @return {Object} Params.\r\n   * @api\r\n   */\r\n  getParams() {\r\n    return this.params_;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\r\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\r\n   * @param {Object} params Params.\r\n   * @return {string|undefined} Request URL.\r\n   * @private\r\n   */\r\n  getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, params) {\r\n    const urls = this.urls;\r\n    if (!urls) {\r\n      return undefined;\r\n    }\r\n    let url;\r\n    if (urls.length == 1) {\r\n      url = urls[0];\r\n    } else {\r\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\r\n      url = urls[index];\r\n    }\r\n\r\n    return getImageSrc(\r\n      tileExtent,\r\n      (\r\n        this.tileGrid || this.getTileGridForProjection(projection)\r\n      ).getResolution(tileCoord[0]),\r\n      pixelRatio,\r\n      projection,\r\n      url,\r\n      params,\r\n      this.serverType_,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get the tile pixel ratio for this source.\r\n   * @param {number} pixelRatio Pixel ratio.\r\n   * @return {number} Tile pixel ratio.\r\n   */\r\n  getTilePixelRatio(pixelRatio) {\r\n    return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   * @return {string} The key for the current params.\r\n   */\r\n  getKeyForParams_() {\r\n    let i = 0;\r\n    const res = [];\r\n    for (const key in this.params_) {\r\n      res[i++] = key + '-' + this.params_[key];\r\n    }\r\n    return res.join('/');\r\n  }\r\n\r\n  /**\r\n   * Update the user-provided params.\r\n   * @param {Object} params Params.\r\n   * @api\r\n   */\r\n  updateParams(params) {\r\n    Object.assign(this.params_, params);\r\n    this.updateV13_();\r\n    this.setKey(this.getKeyForParams_());\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  updateV13_() {\r\n    const version = this.params_['VERSION'] || DEFAULT_VERSION;\r\n    this.v13_ = compareVersions(version, '1.3') >= 0;\r\n  }\r\n\r\n  /**\r\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\r\n   * @param {number} pixelRatio The pixel ratio\r\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\r\n   * @return {string|undefined} The tile URL\r\n   * @override\r\n   */\r\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\r\n    let tileGrid = this.getTileGrid();\r\n    if (!tileGrid) {\r\n      tileGrid = this.getTileGridForProjection(projection);\r\n    }\r\n\r\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\r\n      return undefined;\r\n    }\r\n\r\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\r\n      pixelRatio = 1;\r\n    }\r\n\r\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\r\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\r\n\r\n    const gutter = this.gutter_;\r\n    if (gutter !== 0) {\r\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\r\n    }\r\n\r\n    const baseParams = Object.assign(\r\n      {},\r\n      getRequestParams(this.params_, 'GetMap'),\r\n    );\r\n\r\n    return this.getRequestUrl_(\r\n      tileCoord,\r\n      tileExtent,\r\n      pixelRatio,\r\n      projection,\r\n      baseParams,\r\n    );\r\n  }\r\n}\r\n\r\nexport default TileWMS;\r\n"],
  "mappings": "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",
  "names": []
}
